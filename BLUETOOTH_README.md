# Bluetooth Firmware Patching

## About

Broadcom not only provides WiFi chips but also Bluetooth chips and WiFi+Bluetooth combo chips. Even in combo chips, 
Bluetooth and WiFi firmware run on separate ARM cores. Firmware patching mechanisms for WiFi and Bluetooth offered
by Broadcom differ. However, the generic Nexmon approach of binary patching within the firmware is similar for both.
Bluetooth lower layers did not experience as extensive research as WiFi lower layers yet, so patching them is very
interesting.

Bluetooth support is based on [InternalBlue](https://github.com/seemoo-lab/internalblue) and adds the ability to
write patches in C/C++ instead of plain assembly.

### Persistent Patches

This project supports generating `.hcd` patch files for Broadcom Bluetooth chips. The operating system loads these
`.hcd` files during driver initialization to patch the Bluetooth firmware. `.hcd` patching is the Broadcom standard
for all Bluetooth chips. Even their evaluation boards (for example *CYW920735Q60EVB-01*) that support programming custom
applications with *WICED Studio* install large IoT applications inside the firmware via `.hcd` files.

Since `.hcd` patches are loaded on each driver initialization by the operating system, we call them persistent.
Note that they are not persistent once the `.hcd` file is changed or removed.

To generate a persistent patch, simply call `make`.


### Non-persistent Live Patches

*InternalBlue* already supports live patching in Assembly without Nexmon.
  
`.hcd` files actually just contain a mapping to HCI commands such as `WRITE_RAM` and `LAUNCH_RAM`. It is not required
to execute them within the `.hcd` context. Using HCI commands is easier for testing. If a patch contains errors, the
firmware will just crash once instead of permanently. Moreover, as a connection to the Bluetooth chip is required to
install live patches, this can be used to also parse stack dumps generated by some errors.

**TODO: Expand this to all examples.** 
An *InternalBlue* Python script applying binary Nexmon patches is contained in the NiNo example.
To generate a Python script, call `make python`. If you want to execute it directly after generating it, use
`make internalblue`. 

## Build instructions

### Build patches for ARM Cortex M3 running on the Bluetooth core using a x86 computer running Linux (e.g. Ubuntu 16.04)
* Install some dependencies:
  On Ubuntu / Debian based systems:
  ``` 
  sudo apt-get install git gawk qpdf adb flex bison
  ```
  
  On Arch based systems (to be checked):
  ```
  yay -S git gawk qpdf adb flex bison
  ```
* **Only necessary for x86_64 systems**, install i386 libs: 
  On Ubuntu / Debian based systems:
  ```
  sudo dpkg --add-architecture i386
  sudo apt-get update
  sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
  ```
  On Arch based systems:
  ```
  # Enable multilib in the 
  # /etc/pacman.conf
  # by uncommenting the following two lines:
  # [multilib]
  # Include = /etc/pacman.d/mirrorlist
  sudo pacman -Syu
  # lib32-gcc-libs contains lib32-libstdc++6
  # vim contains xxd
  sudo pacman -S lib32-glibc lib32-ncurses lib32-gcc-libs vim
  ```
* Clone our repository:

      git clone https://github.com/seemoo-lab/nexmon.git
    
* Go to the root directory of the repository, switch to the *bluetooth-wip* branch, setup the build environment and compile
some build tools and extract the content from the original HCD files.
  
      cd nexmon
      git checkout bluetooth-wip
      source setup_env.sh
      make


##### Build Persistent Patches

* Go to the `patches` folder of your target device (e.g. `bcm4335c0_BT` for the *Nexus 5*), setup the build environment (again),
go to the folder of the patch you want to build and build it. 
    
      cd patches/bcm4335c0_BT/nexmon
      source setup_env.sh
      cd NiNo_PoC
      make
      
* The following will install the patched `.hcd` file. **Make a backup `.hcd` file before!**

      make backup-hcd
      make install-patch
      
* If something fails, reinstall your original `.hcd` file.

      make install-backup
      
*InternalBlue* is not required for building persistent patches.
However, patches that are not 4-byte-aligned and inside ROM require a valid memory dump. If you want to add support
for a new chip, you will need *InternalBlue* to do so.


##### Build Live Patches

* Set up the [InternalBlue](https://github.com/seemoo-lab/internalblue) project and install its cli using `setup.py`. 

* Go to the `patches` folder of your target device (e.g. `bcm4335c0_BT` for the *Nexus 5*), setup the build environment (again),
go to the folder of the patch you want to build. 
    
      cd patches/bcm4335c0_BT/nexmon
      source setup_env.sh
      cd NiNo_PoC

* To generate a Python script anyone with *InternalBlue* can use to apply the patch, even without the *Nexmon* build
environment, run:

      make python

* During patch development, directly installing the patch via *InternalBlue* to the first ADB device found might be more practical:

      make internalblue

After running the patch, you can open another *InternalBlue* instance while testing your patch or modify the Python
script not to close the *InternalBlue* connection. Some errors will trigger coredumps, meaning that the Bluetooth
chip prints all registers and RAM contents via HCI. Especially on an evaluation board with lots of RAM this might
take a while. On a selection of chips, *InternalBlue* also supports a `tracepoint` feature, which is similar to a
coredumpâ€”but only executed once and firmware execution is continued afterwards.

### Where to find what?

#### Buildtools
base path: `nexmon/buildtools`

**hcd-extractor:** `buildtools/hcd-extractor`

This tool parses and extracts patches from an existing `.hcd`-file. The extracted patches are later used to generate another - valid - patch file. 

**hcd-generator:** `buildtools/hcd-generator`

The extracted patches, as well as the user written ones are merged together into a valid hcd file using this tool.

**nexmon.mk.2_bt.awk:** `buildtools/scripts/nexmon.mk.2_bt.awk`

This awk-script is used to generate a proper `MAKEFILE` under consideration that we don't build a WiFi firmware patch, but a Bluetooth one. 

#### Firmware

**BCM 43305c0:**
- firmware: `firmware/bcm4335c0_BT/` 

#### Common Code
**common between all nexmon projects:**

- common  - source/c-files: `patches/common`
- include - source/h-files: `patches/include`

**common between all nexmon-bluetooth projects:**

- common  - source/c-files: `patches/common/bluetooth`
- include - source/h-files: `patches/include/bluetooth`

#### Provided Patches

patch sources base path: `patches/bcm4335c0_BT`

**CVE_2018_5383:** `patches/bcm4335c0_BT/nexmon/CVE_2018_5383`

Proof of concept for the vulnerability with the [CVE 2018 5383](https://nvd.nist.gov/vuln/detail/CVE-2018-5383). This is (currently) only the basic assembly PoC wrapped into a C-function.
After installing this patch follow these instructions:
1. Start InternalBlue CLI for Nexus 5 and activate the LMP monitor.
2. Pair the Nexus 5 with the other BT device
3. If pairing fails with message 'Incorrect PIN', repeat step 2.
   If the other device is vulnerable, pairing succeeds with 50% probability.
   If the other device is NOT vulnerable, pairing never succeeds.
4. After pairing was successful, check the LMP capture and verify that
   the Nexus 5 sent zero as y-coordinate in the 'encapsulated payload' packet

**NiNo_PoC:** `patches/bcm4335c0_BT/nexmon/NiNo_PoC`

>In a NiNo attack an active MITM fakes that the other device has no in put and no output capabilities. We think smartphones should not accept that or show a big warning ("Is this really a headset without display?!"), but in implementations we saw this does not happen. With NiNo, secure simple pairing will still be present, but in "Just Works" mode which is suspect to MITM.
[source](https://github.com/seemoo-lab/internalblue/blob/master/examples/NiNo_PoC.py)

This project holds the original plain assembly PoC as well as a C-based implementation.

**empty_test:** `patches/bcm4335c0_BT/nexmon/empty_test`

This is an empty test project containing the basic patch-layout including a valid makefile. This can be used as template for new patches.
