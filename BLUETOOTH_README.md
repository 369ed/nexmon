# Bluetooth Firmware Patching

## About

Broadcom not only provides WiFi chips but also Bluetooth chips and WiFi+Bluetooth combo chips. Even in combo chips, 
Bluetooth and WiFi firmware run on separate ARM cores. Firmware patching mechanisms for WiFi and Bluetooth offered
by Broadcom differ. However, the generic Nexmon approach of binary patching within the firmware is similar for both.
Bluetooth lower layers did not experience as extensive research as WiFi lower layers yet, so patching them is very
interesting.

Bluetooth support is based on [InternalBlue](https://github.com/seemoo-lab/internalblue) and adds the ability to
write patches in C/C++ instead of plain assembly.

### Persistent Patches

This project supports generating `.hcd` patch files for Broadcom Bluetooth chips. The operating system loads these
`.hcd` files during driver initialization to patch the Bluetooth firmware. `.hcd` patching is the Broadcom standard
for all Bluetooth chips. Even their evaluation boards (for example *CYW920735Q60EVB-01*) that support programming custom
applications with *WICED Studio* install large IoT applications inside the firmware via `.hcd` files.

Since `.hcd` patches are loaded on each driver initialization by the operating system, we call them persistent.
Note that they are not persistent once the `.hcd` file is changed or removed.


### Non-persistent Live Patches

 *InternalBlue* already supports live patching in Assembly without Nexmon.
 
 **TODO: Make a new Makefile that installs C patches via InternalBlue.** In principle this is possible, we just did
 not do this so far.
  
`.hcd` files actually just contain a mapping to HCI commands such as `WRITE_RAM` and `LAUNCH_RAM`. It is not required
to execute them within the `.hcd` context. Using HCI commands is easier for testing. If a patch contains errors, the
firmware will just crash once instead of permanently. Moreover, as a connection to the Bluetooth chip is required to
install live patches, this can be used to also parse stack dumps generated by some errors.


## Build instructions

### Build patches for ARM Cortex M3 running on the Bluetooth core using a x86 computer running Linux (e.g. Ubuntu 16.04)
* Install some dependencies:
  On Ubuntu / Debian based systems:
  ``` 
  sudo apt-get install git gawk qpdf adb flex bison
  ```
  
  On Arch based systems (to be checked):
  ```
  yay -S git gawk qpdf adb flex bison
  ```
* **Only necessary for x86_64 systems**, install i386 libs: 
  On Ubuntu / Debian based systems:
  ```
  sudo dpkg --add-architecture i386
  sudo apt-get update
  sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
  ```
  On Arch based systems:
  ```
  # Enable multilib in the 
  # /etc/pacman.conf
  # by uncommenting the following two lines:
  # [multilib]
  # Include = /etc/pacman.d/mirrorlist
  sudo pacman -Syu
  # lib32-gcc-libs contains lib32-libstdc++6
  # vim contains xxd
  sudo pacman -S lib32-glibc lib32-ncurses lib32-gcc-libs vim
  ```
* Set up the [InternalBlue](https://github.com/seemoo-lab/internalblue) project and install its cli using `setup.py`. 
InternalBlue is needed while compiling patches to non 4-byte aligned addresses and for live patching.
* Clone our repository:

      git clone https://github.com/seemoo-lab/nexmon.git
    
* Go to the root directory of the repository, switch to the *bluetooth-wip* branch, setup the build environment and compile
some build tools and extract the content from the original HCD files.
  
      cd nexmon
      git checkout bluetooth-wip
      source setup_env.sh
      make
  
* Go to the *patches* folder of your target device (e.g. bcm4335c0 for the Nexus 5), setup the build environment (again),
go to the folder of the patch you want to build and build it. In some cases you already need to be connected to your
target device to apply patches. For example this is a requirement on the Nexus 5 if your patch is not in a 
4-byte-aligned position. 
    
      cd patches/bcm4335c0_BT/nexmon
      source setup_env.sh
      cd NiNo_PoC
      make
      
* The following will install the patched `.hcd` file. **Make a backup `.hcd` file before!**

      make backup-hcd
      make install-patch
      
* If something fails, reinstall your original `.hcd` file.

      make install-backup 
      
  

### Where to find what?

#### Buildtools
base path: `nexmon/buildtools`

**hcd-extractor:** `buildtools/hcd-extractor`

This tool parses and extracts patches from an existing `.hcd`-file. The extracted patches are later used to generate another - valid - patch file. 

**hcd-generator:** `buildtools/hcd-generator`

The extracted patches, as well as the user written ones are merged together into a valid hcd file using this tool.

**nexmon.mk.2_bt.awk:** `buildtools/scripts/nexmon.mk.2_bt.awk`

This awk-script is used to generate a proper `MAKEFILE` under consideration that we don't build a WiFi firmware patch, but a bluetooth one. 

**bt_patch_alignment.py**: `buildtools/scripts/bt_patch_alignment.py`

This script handles 4-byte alignment If the patches which is going to be compiled patches at a non 4-byte-aligned address, it is needed to create an aligned patch. This is needed due to the fact that it's only possible to write to 4-byte aligned addresses.

#### Firmware

**BCM 4330c0:**
- firmware: `firmware/bcm433c0_BT/` 

#### Common Code
**common between all nexmon projects:**

- common  - source/c-files: `patches/common`
- include - source/h-files: `patches/include`

**common between all nexmon-bluetooth projects:**

- common  - source/c-files: `patches/common/bluetooth`
- include - source/h-files: `patches/include/bluetooth`

#### Provided Patches

patch sources base path: `patches/bcm4335c0_BT`

**CVE_2018_5383:** `patches/bcm4335c0_BT/nexmon/CVE_2018_5383`

Proof of concept for the vulnerability with the [CVE 2018 5383](https://nvd.nist.gov/vuln/detail/CVE-2018-5383). This is (currently) only the basic assembly PoC wrapped into a C-function.
After installing this patch follow these instructions:
1. Start InternalBlue CLI for Nexus 5 and activate the LMP monitor.
2. Pair the Nexus 5 with the other BT device
3. If pairing fails with message 'Incorrect PIN', repeat step 2.
   If the other device is vulnerable, pairing succeeds with 50% probability.
   If the other device is NOT vulnerable, pairing never succeeds.
4. After pairing was successful, check the LMP capture and verify that
   the Nexus 5 sent zero as y-coordinate in the 'encapsulated payload' packet

**NiNo_PoC:** `patches/bcm4335c0_BT/nexmon/NiNo_PoC`

>In a NiNo attack an active MITM fakes that the other device has no in put and no output capabilities. We think smartphones should not accept that or show a big warning ("Is this really a headset without display?!"), but in implementations we saw this does not happen. With NiNo, secure simple pairing will still be present, but in "Just Works" mode which is suspect to MITM.
[source](https://github.com/seemoo-lab/internalblue/blob/master/examples/NiNo_PoC.py)

This project holds the original plain assembly PoC as well as a C-based implementation.

**empty_test:** `patches/bcm4335c0_BT/nexmon/empty_test`

This is an empty test project containing the basic patch-layout including a valid makefile. This can be used as template for new patches.
